package com.vinaooo.revenger.gamepad

import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.*
import androidx.activity.ComponentActivity
import androidx.lifecycle.lifecycleScope
import com.vinaooo.revenger.R
import kotlinx.coroutines.launch

/**
 * Activity completa de testes para valida√ß√£o da migra√ß√£o RadialGamePad ‚Üí VirtualJoystick
 * @author vinaooo
 * @date 22 de Setembro de 2025
 */
class ComprehensiveTestActivity : ComponentActivity() {

    companion object {
        private const val TAG = "ComprehensiveTest"
    }

    // Sistema de testes
    private lateinit var testingSystem: GamePadTestingSystem

    // Views da UI
    private lateinit var systemSpinner: Spinner
    private lateinit var modeToggle: ToggleButton
    private lateinit var runTestsButton: Button
    private lateinit var resultsText: TextView
    private lateinit var progressBar: ProgressBar
    private lateinit var leftContainer: FrameLayout
    private lateinit var rightContainer: FrameLayout

    // Estado atual
    private var currentConfig: VirtualJoystickConfig = VirtualJoystickConfig.defaultConfig()
    private var testResults: List<GamePadTestingSystem.TestResult> = emptyList()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_comprehensive_test)

        initializeViews()
        setupTestingSystem()
        setupControls()

        Log.d(TAG, "ComprehensiveTestActivity iniciada")
    }

    private fun initializeViews() {
        systemSpinner = findViewById(R.id.systemSpinner)
        modeToggle = findViewById(R.id.modeToggle)
        runTestsButton = findViewById(R.id.runTestsButton)
        resultsText = findViewById(R.id.resultsText)
        progressBar = findViewById(R.id.progressBar)
        leftContainer = findViewById(R.id.leftContainer)
        rightContainer = findViewById(R.id.rightContainer)
    }

    private fun setupTestingSystem() {
        // Inicializa sistema de testes
        testingSystem = GamePadTestingSystem(this, this)

        // Mock do GameActivityViewModel (para testes)
        // Em implementa√ß√£o real, seria injetado
        val gameActivityViewModel =
                com.vinaooo.revenger.viewmodels.GameActivityViewModel(application)
        testingSystem.initialize(gameActivityViewModel)
    }

    private fun setupControls() {
        // Configura spinner de sistemas
        val systems =
                arrayOf(
                        "Mega Drive (Sonic & Knuckles)",
                        "Super Nintendo (Rock & Roll Racing)",
                        "Game Boy (Legend of Zelda)",
                        "Master System (Sonic The Hedgehog)",
                        "Dual Analog (Teste)",
                        "Padr√£o"
                )

        val adapter = ArrayAdapter(this, android.R.layout.simple_spinner_item, systems)
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        systemSpinner.adapter = adapter

        systemSpinner.onItemSelectedListener =
                object : AdapterView.OnItemSelectedListener {
                    override fun onItemSelected(
                            parent: AdapterView<*>?,
                            view: View?,
                            position: Int,
                            id: Long
                    ) {
                        currentConfig =
                                when (position) {
                                    0 -> VirtualJoystickSystemConfigs.megaDriveConfig()
                                    1 -> VirtualJoystickSystemConfigs.snesConfig()
                                    2 -> VirtualJoystickSystemConfigs.gameBoyConfig()
                                    3 -> VirtualJoystickSystemConfigs.masterSystemConfig()
                                    4 -> VirtualJoystickSystemConfigs.dualAnalogConfig()
                                    else -> VirtualJoystickConfig.defaultConfig()
                                }

                        updateConfigDisplay()
                        Log.d(TAG, "Sistema selecionado: ${currentConfig.name}")
                    }

                    override fun onNothingSelected(parent: AdapterView<*>?) {}
                }

        // Toggle entre RadialGamePad e VirtualJoystick
        modeToggle.setOnCheckedChangeListener { _, isChecked ->
            val mode =
                    if (isChecked) {
                        modeToggle.text = "VirtualJoystick"
                        GamePadTestingSystem.GamePadMode.VIRTUAL
                    } else {
                        modeToggle.text = "RadialGamePad"
                        GamePadTestingSystem.GamePadMode.RADIAL
                    }

            testingSystem.switchMode(mode, leftContainer, rightContainer, null)
            Log.d(TAG, "Modo alternado para: $mode")
        }

        // Bot√£o de executar testes
        runTestsButton.setOnClickListener { runComprehensiveTests() }

        // Estado inicial
        modeToggle.isChecked = true // Inicia com VirtualJoystick
        updateConfigDisplay()
    }

    private fun updateConfigDisplay() {
        val info =
                """
            üìã CONFIGURA√á√ÉO ATUAL
            
            Sistema: ${currentConfig.name}
            Joystick Esquerdo: ${if (currentConfig.leftJoystickEnabled) "‚úÖ" else "‚ùå"}
            Joystick Direito: ${if (currentConfig.rightJoystickEnabled) "‚úÖ" else "‚ùå"}
            Raio: ${currentConfig.joystickRadius}px
            Sensibilidade: ${currentConfig.sensitivity}x
            Auto Visibilidade: ${if (currentConfig.autoVisibility) "‚úÖ" else "‚ùå"}
            
            üé® CORES:
            Fundo: #${String.format("%08X", currentConfig.backgroundColor)}
            Borda: #${String.format("%08X", currentConfig.borderColor)}
            Bot√£o: #${String.format("%08X", currentConfig.knobColor)}
        """.trimIndent()

        resultsText.text = info
    }

    private fun runComprehensiveTests() {
        if (progressBar.visibility == View.VISIBLE) {
            Log.w(TAG, "Testes j√° em andamento")
            return
        }

        // UI de loading
        progressBar.visibility = View.VISIBLE
        runTestsButton.isEnabled = false
        resultsText.text =
                "üöÄ Executando bateria completa de testes...\nIsto pode levar alguns minutos."

        lifecycleScope.launch {
            try {
                testingSystem.runFullTestSuite(leftContainer, rightContainer, null) { results ->
                    // Callback quando testes terminam
                    testResults = results
                    displayTestResults()

                    // UI cleanup
                    progressBar.visibility = View.GONE
                    runTestsButton.isEnabled = true

                    Log.i(TAG, "Testes conclu√≠dos: ${results.size} resultados")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Erro durante os testes", e)
                resultsText.text = "‚ùå Erro durante os testes: ${e.message}"

                progressBar.visibility = View.GONE
                runTestsButton.isEnabled = true
            }
        }
    }

    private fun displayTestResults() {
        val report = testingSystem.generateComparisonReport()
        val detailedResults = buildDetailedReport()

        val fullReport =
                """
            $report
            
            üìã RESULTADOS DETALHADOS:
            $detailedResults
            
            üéØ RECOMENDA√á√ïES:
            ${generateRecommendations()}
        """.trimIndent()

        resultsText.text = fullReport

        // Salva relat√≥rio em arquivo
        saveReportToFile(fullReport)
    }

    private fun buildDetailedReport(): String {
        val report = StringBuilder()

        testResults.groupBy { it.system }.forEach { (system, results) ->
            report.append("\nüéÆ $system:\n")

            results.forEach { result ->
                val status = if (result.success) "‚úÖ" else "‚ùå"
                report.append("  $status ${result.mode.name}: ")
                report.append("Init=${result.initTime}ms, ")
                report.append("Response=${result.responseTime}ms, ")
                report.append("Memory=${result.memoryUsage}KB\n")

                if (result.notes.isNotEmpty()) {
                    report.append("    üìù ${result.notes}\n")
                }
            }
        }

        return report.toString()
    }

    private fun generateRecommendations(): String {
        val virtualResults =
                testResults.filter { it.mode == GamePadTestingSystem.GamePadMode.VIRTUAL }
        val radialResults =
                testResults.filter { it.mode == GamePadTestingSystem.GamePadMode.RADIAL }

        val recommendations = mutableListOf<String>()

        // An√°lise de performance
        if (virtualResults.isNotEmpty() && radialResults.isNotEmpty()) {
            val virtualAvgInit = virtualResults.map { it.initTime }.average()
            val radialAvgInit = radialResults.map { it.initTime }.average()

            if (virtualAvgInit < radialAvgInit) {
                recommendations.add("‚úÖ VirtualJoystick tem inicializa√ß√£o mais r√°pida")
            } else {
                recommendations.add("‚ö†Ô∏è RadialGamePad tem inicializa√ß√£o mais r√°pida")
            }

            val virtualAvgResponse = virtualResults.map { it.responseTime }.average()
            val radialAvgResponse = radialResults.map { it.responseTime }.average()

            if (virtualAvgResponse < radialAvgResponse) {
                recommendations.add("‚úÖ VirtualJoystick tem melhor tempo de resposta")
            }
        }

        // An√°lise de sucesso
        val virtualSuccessRate =
                if (virtualResults.isNotEmpty())
                        virtualResults.count { it.success }.toDouble() / virtualResults.size
                else 0.0
        val radialSuccessRate =
                if (radialResults.isNotEmpty())
                        radialResults.count { it.success }.toDouble() / radialResults.size
                else 0.0

        if (virtualSuccessRate >= 0.9) {
            recommendations.add(
                    "‚úÖ VirtualJoystick tem alta confiabilidade (${(virtualSuccessRate * 100).toInt()}%)"
            )
        }

        // Recomenda√ß√µes espec√≠ficas por sistema
        val systemsWithIssues = testResults.filter { !it.success }.map { it.system }.distinct()
        if (systemsWithIssues.isNotEmpty()) {
            recommendations.add(
                    "‚ö†Ô∏è Sistemas com problemas: ${systemsWithIssues.joinToString(", ")}"
            )
        }

        return if (recommendations.isNotEmpty()) {
            recommendations.joinToString("\n")
        } else {
            "‚úÖ Todos os testes passaram sem problemas detectados"
        }
    }

    private fun saveReportToFile(report: String) {
        try {
            val fileName = "gamepad_test_report_${System.currentTimeMillis()}.txt"
            openFileOutput(fileName, MODE_PRIVATE).use { output ->
                output.write(report.toByteArray())
            }

            Log.i(TAG, "Relat√≥rio salvo: $fileName")
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao salvar relat√≥rio", e)
        }
    }

    override fun onDestroy() {
        testingSystem.cleanup()
        super.onDestroy()
    }
}
